/*
 * generated by Xtext 2.24.0
 */
package sdu.mdsd.restful.validation

import sdu.mdsd.restful.restControllerGeneration.Entity
import sdu.mdsd.restful.restControllerGeneration.RestControllerGenerationPackage.Literals
import java.util.HashSet
import java.util.Set
import org.eclipse.xtext.validation.Check
import static sdu.mdsd.restful.generator.RestControllerGenerationGenerator.getAllAttributesStatic
import sdu.mdsd.restful.restControllerGeneration.Attribute
import org.eclipse.xtext.EcoreUtil2
import sdu.mdsd.restful.restControllerGeneration.ExternalUseOfAttribute
import sdu.mdsd.restful.restControllerGeneration.AttributeType
import sdu.mdsd.restful.restControllerGeneration.SimpleType
import sdu.mdsd.restful.restControllerGeneration.RefType
import sdu.mdsd.restful.restControllerGeneration.ListType
import sdu.mdsd.restful.restControllerGeneration.AttributeUse
import sdu.mdsd.restful.restControllerGeneration.Reference
import sdu.mdsd.restful.restControllerGeneration.CreateMethod
import sdu.mdsd.restful.restControllerGeneration.Controller

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RestControllerGenerationValidator extends AbstractRestControllerGenerationValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					RestControllerGenerationPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkEntityNoCyclicBase(Entity entity) {
		val seen = new HashSet<String>
		seen.add(entity.name)
		if(entity.base.selfInherits(seen)) {
			error('Cyclic base relation',Literals.ENTITY__BASE,"cyclicInheritance")
		}
	}
	
	def boolean selfInherits(Entity next, Set<String> seen) {
		if(next===null) false
		else if(seen.contains(next.name)) true
		else { seen.add(next.name) next.base.selfInherits(seen) }
	}
	
	@Check
	def checkNoDuplicateAttribute(Attribute attribute) {
		val entity = EcoreUtil2.getContainerOfType(attribute, Entity)
		val baseAttributes = getAllAttributesStatic(entity.base)
		if(baseAttributes.exists[name == attribute.name]) {
			error('Duplicate attribute name from base',Literals.ATTRIBUTE__NAME,"duplicateName")
		}
	}
	
	@Check
	def checkRequirementType(ExternalUseOfAttribute requirement) {
		if(!compareAttributeType(requirement.external.type, requirement.attribute.getAttributeType)) {
			error('Type mismatch between external function and attribute', Literals.EXTERNAL_USE_OF_ATTRIBUTE__ATTRIBUTE, 'typeMismatch')
		}
	}
	
	def private boolean compareAttributeType(AttributeType type, AttributeType other) {
		if(type === null) return false
		if(other === null) return false
		if(type.class != other.class) return false
		
		switch type {
			SimpleType: {
				val type2 = other as SimpleType
				type.type.name == type2.type.name
			}
			RefType: {
				val type2 = other as RefType
				type.type.name == type2.type.name
			}
			ListType: {
				val type2 = other as RefType
				type.type.name == type2.type.name
			}
			default: false
		}
	}
	
	def dispatch private getAttributeType(AttributeUse attribute) { attribute.attribute.type }
	def dispatch private getAttributeType(Reference reference) { reference.attribute.type }
	
	@Check
	def checkLogicExpToExcludeListType(Reference reference) {
		if(reference.reference.type instanceof SimpleType || reference.reference.type instanceof RefType) return
		val Controller controller = EcoreUtil2.getContainerOfType(reference, Controller)
		if(controller === null) {
			error('Referencing list attribute type only allowed in controller methods', Literals.REFERENCE__REFERENCE, 'illegalAttributeType')
		}
	}
	
	@Check
	def checkCorrectCreateWithCount(CreateMethod method) {
		val Controller controller = EcoreUtil2.getContainerOfType(method, Controller)
		val int nonSimpleAttributeCount = getAllAttributesStatic(controller.entity).filter[type instanceof RefType || type instanceof ListType].length
		val int withMethodCount = method.withEntity.length
		if(nonSimpleAttributeCount != withMethodCount) {
			error('All entity relationships must be mentioned', Literals.CREATE_METHOD__WITH_ENTITY, 'incorrectWithEntityCount')
		}
	}
}
